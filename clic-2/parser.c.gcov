        -:    0:Source:parser.c
        -:    0:Programs:4
        -:    1:
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <string.h>
        -:    5:#include <math.h>
        -:    6:#include <ctype.h>
        -:    7:#include <dlfcn.h>
        -:    8:#include "list.h"
        -:    9:#include "pstack.h"
        -:   10:#include "parser.h"
        -:   11:
        -:   12:#define LIBMNSYM 17
        -:   13:#define MAXCSTRLEN 8
        -:   14:
        -:   15:static char cprefix[] = "_const_";
        -:   16:
        -:   17:char *parser_error_msgs[ERRN] = {
        -:   18:	"everything in the garden's lovely",
        -:   19:	"oops...bug in parser",
        -:   20:	"invalid parser",
        -:   21:	"no memory",
        -:   22:	"invalid variable or function name",
        -:   23:	"invalid constant",
        -:   24:	"constant storage is full",
        -:   25:	"name conflict",
        -:   26:	"unknown identifier",
        -:   27:	"syntax error",
        -:   28:	"stack overflow",
        -:   29:	"why so many constants? :-)",
        -:   30:	"expression too complicated",
        -:   31:	"you can not change the value"
        -:   32:};
        -:   33:
        -:   34:char *libmsyms[LIBMNSYM] = {
        -:   35:	"sin",
        -:   36:	"cos",
        -:   37:	"tan",
        -:   38:	"asin",
        -:   39:	"acos",
        -:   40:	"atan",
        -:   41:	"exp",
        -:   42:	"log",
        -:   43:	"log10",
        -:   44:	"sqrt",
        -:   45:	"cbrt",
        -:   46:	"sinh",
        -:   47:	"cosh",
        -:   48:	"tanh",
        -:   49:	"erf",
        -:   50:	"erfc",
        -:   51:	"tgamma"
        -:   52:};
        -:   53:
        -:   54:char *mfname[LIBMNSYM] = {
        -:   55:	"sin",
        -:   56:	"cos",
        -:   57:	"tg",
        -:   58:	"arcsin",
        -:   59:	"arccos",
        -:   60:	"arctg",
        -:   61:	"exp",
        -:   62:	"ln",
        -:   63:	"lg",
        -:   64:	"sqrt",
        -:   65:	"cbrt",
        -:   66:	"sh",
        -:   67:	"ch",
        -:   68:	"th",
        -:   69:	"erf",
        -:   70:	"erfc",
        -:   71:	"G"
        -:   72:};
        -:   73:
        -:   74:static double e;
        -:   75:static double PI;
        -:   76:
        -:   77:/* helping functions */
        -:   78:
        -:   79:int check_item_name(void *v1, void *v2);
        -:   80:int check_item_val(void *v1, void *v2);
        -:   81:int check_item_addr(void *v1, void *v2);
        -:   82:
        -:   83:EXPR_ITEM *find_item_by_name(LIST *list, char *vn);
        -:   84:EXPR_ITEM *find_item_by_val(LIST *list, double vv);
        -:   85:EXPR_ITEM *find_item_by_addr(LIST *list, double *loc);
        -:   86:
        -:   87:PARSER_ERROR valid_expr(PARSER*, EXPR*);
        -:   88:
        -:   89:void delete_expr_item(void *dp);
        -:   90:void delete_expr(void *ex);
        -:   91:
function check_item_name called 685632 returned 100% blocks executed 100%
   685632:   92:int check_item_name(void *v1, void *v2)
        -:   93:{
   685632:   94:	EXPR_ITEM *var1 = (EXPR_ITEM*)v1;
   685632:   95:	EXPR_ITEM *var2 = (EXPR_ITEM*)v2;
        -:   96:	
   685632:   97:	int cr = strcmp(var1->name, var2->name);
        -:   98:	
   685632:   99:	return (cr == 0)?(1):(0);
        -:  100:}
        -:  101:
function check_item_val called 13465 returned 100% blocks executed 100%
    13465:  102:int check_item_val(void *v1, void *v2)
        -:  103:{
    13465:  104:	EXPR_ITEM *var1 = (EXPR_ITEM*)v1;
    13465:  105:	EXPR_ITEM *var2 = (EXPR_ITEM*)v2;
    13465:  106:	return (*(double*)var1->loc == *(double*)var2->loc);
        -:  107:}
        -:  108:
function check_item_addr called 0 returned 0% blocks executed 0%
    #####:  109:int check_item_addr(void *v1, void *v2)
        -:  110:{
    #####:  111:	EXPR_ITEM *var1 = (EXPR_ITEM*)v1;
    #####:  112:	EXPR_ITEM *var2 = (EXPR_ITEM*)v2;
    #####:  113:	return (var1->loc == var2->loc);
        -:  114:}
        -:  115:
function find_item_by_name called 3555 returned 100% blocks executed 100%
     3555:  116:EXPR_ITEM *find_item_by_name(LIST *list, char *vn)
        -:  117:{
        -:  118:	EXPR_ITEM sei;
     3555:  119:	sei.name = vn;
        -:  120:	
     3555:  121:	return (EXPR_ITEM*)list_find_first(list, (void*)&sei, check_item_name);
call    0 returned 100%
        -:  122:}
        -:  123:
function find_item_by_val called 1183 returned 100% blocks executed 100%
     1183:  124:EXPR_ITEM *find_item_by_val(LIST *list, double vv)
        -:  125:{
        -:  126:	EXPR_ITEM sei;
     1183:  127:	double v = vv;
     1183:  128:	sei.loc = &v;
        -:  129:	
     1183:  130:	return (EXPR_ITEM*)list_find_first(list, (void*)&sei, check_item_val);
call    0 returned 100%
        -:  131:}
        -:  132:
function find_item_by_addr called 0 returned 0% blocks executed 0%
    #####:  133:EXPR_ITEM *find_item_by_addr(LIST *list, double *loc)
        -:  134:{
        -:  135:	EXPR_ITEM sei;
    #####:  136:	sei.loc = loc;
        -:  137:	
    #####:  138:	return (EXPR_ITEM*)list_find_first(list, (void*)&sei, check_item_addr);
call    0 never executed
        -:  139:}
        -:  140:
function const_exists_by_val called 0 returned 0% blocks executed 0%
    #####:  141:int const_exists_by_val(PARSER *p, double c)
        -:  142:{
        -:  143:	int k, match;
    #####:  144:	for (k = 0; k <= p->last_const; k++) {
branch  0 never executed
branch  1 never executed
    #####:  145:		match = (p->const_arr[k] == c);
    #####:  146:		if (match)
branch  0 never executed
branch  1 never executed
    #####:  147:			break;
        -:  148:	};
    #####:  149:	return match;
        -:  150:}
        -:  151:
function delete_expr_item called 1180 returned 100% blocks executed 100%
     1180:  152:void delete_expr_item(void*dp)
        -:  153:{
     1180:  154:	EXPR_ITEM *ei = (EXPR_ITEM*)dp;
     1180:  155:	if (ei->type == constant) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
      128:  156:		free(ei->name);
        -:  157:	};
     1180:  158:	free(ei);
     1180:  159:}
        -:  160:
        -:  161:/* end of helping functions */
        -:  162:
        -:  163:
        -:  164:/*
        -:  165:	+, -, *, /, ^
        -:  166:*/
        -:  167:
function p_add called 2 returned 100% blocks executed 100%
        2:  168:double p_add(double *a)
        -:  169:{
        2:  170:	return a[0]+a[1];
        -:  171:}
        -:  172:
function p_sub called 2 returned 100% blocks executed 100%
        2:  173:double p_sub(double *a)
        -:  174:{
        2:  175:	return a[0]-a[1];
        -:  176:}
        -:  177:
function p_mul called 2 returned 100% blocks executed 100%
        2:  178:double p_mul(double *a)
        -:  179:{
        2:  180:	return a[0]*a[1];
        -:  181:}
        -:  182:
function p_div called 3 returned 100% blocks executed 100%
        3:  183:double p_div(double *a)
        -:  184:{
        3:  185:	return a[0]/a[1];
        -:  186:}
        -:  187:
function p_pow called 0 returned 0% blocks executed 0%
    #####:  188:double p_pow(double *a)
        -:  189:{
    #####:  190:	return pow(a[0],a[1]);
        -:  191:}
        -:  192:
function p_neg called 6 returned 100% blocks executed 100%
        6:  193:double p_neg(double *a)
        -:  194:{
        6:  195:	return -a[0];
        -:  196:}
        -:  197:
function p_nul called 0 returned 0% blocks executed 0%
    #####:  198:double p_nul(double *a)
        -:  199:{
    #####:  200:	return a[0];
        -:  201:}
        -:  202:
function parser_error called 0 returned 0% blocks executed 0%
    #####:  203:PARSER_ERROR parser_error(PARSER *p)
        -:  204:{
    #####:  205:	if (!p)
branch  0 never executed
branch  1 never executed
    #####:  206:		return pe_noparser;
    #####:  207:	return p->error;
        -:  208:}
        -:  209:
function parser_errorstr called 9 returned 100% blocks executed 75%
        9:  210:char *parser_errorstr(PARSER_ERROR ercode)
        -:  211:{
        9:  212:	if (ercode == pe_ok)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  213:		return NULL;
        9:  214:	return parser_error_msgs[ercode];
        -:  215:}
        -:  216:
function parser_create called 1 returned 100% blocks executed 58%
        1:  217:PARSER *parser_create(int stack_size, int maxconst, int maxfargs, int maxires)
        -:  218:{
        -:  219:	PARSER *parser;
        -:  220:	int k;
        -:  221:	void* prog;
        -:  222:	double (*libmsym)(double*);
        -:  223:	char *dlerr;
        -:  224:	char test[MAXCSTRLEN];
        -:  225:	int iii;
        -:  226:	
        1:  227:	parser = (PARSER*)malloc(sizeof(PARSER));
        1:  228:	if ( !parser ) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  229:		return NULL;
        -:  230:	};
        -:  231:
        1:  232:	parser->error      = pe_ok;
        1:  233:	parser->var_list   = NULL;
        1:  234:	parser->fun_list   = NULL;
        1:  235:	parser->expr_list  = NULL;
        1:  236:	parser->const_list = NULL;
        1:  237:	parser->const_arr  = NULL;
        1:  238:	parser->last_const = 0;
        1:  239:	parser->maxconst   = maxconst;
        1:  240:	parser->fargs      = NULL;
        1:  241:	parser->maxfargs   = maxfargs;
        1:  242:	parser->imres      = NULL;
        1:  243:	parser->maxires    = maxires;
        1:  244:	parser->stack      = NULL;
        -:  245:	
        1:  246:	if (snprintf(test, MAXCSTRLEN, "%d", maxconst) == -1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  247:		parser->error = pe_toomanyconst;
    #####:  248:		goto clean_up;
        -:  249:	};
        1:  250:	parser->const_nmlen = strlen(test)+strlen(cprefix);
        -:  251:	
        1:  252:	parser->var_list = list_create();
call    0 returned 100%
        1:  253:	if (!parser->var_list) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  254:		parser->error = pe_nomemory;
    #####:  255:		goto clean_up;
        -:  256:	};
        -:  257:
        1:  258:	parser->fun_list = list_create();
call    0 returned 100%
        1:  259:	if (!parser->fun_list) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  260:		parser->error = pe_nomemory;
    #####:  261:		goto clean_up;
        -:  262:	};
        -:  263:
        1:  264:	parser->const_list = list_create();
call    0 returned 100%
        1:  265:	if (!parser->const_list) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  266:		parser->error = pe_nomemory;
    #####:  267:		goto clean_up;
        -:  268:	};
        -:  269:
        1:  270:	parser->const_arr = (double*)malloc(maxconst*sizeof(double));
        1:  271:	if (!parser->const_arr) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  272:		parser->error = pe_nomemory;
    #####:  273:		goto clean_up;
        -:  274:	};
        -:  275:	
        1:  276:	parser->imres = (double*)malloc(maxires*sizeof(double));
        1:  277:	if (!parser->imres) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  278:		parser->error = pe_nomemory;
    #####:  279:		goto clean_up;
        -:  280:	};
        -:  281:	
        1:  282:	parser->fargs = (double*)malloc(maxfargs*sizeof(double));
        1:  283:	if (!parser->fargs ){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  284:		parser->error = pe_nomemory;
    #####:  285:		goto clean_up;
        -:  286:	};
        -:  287:
        -:  288:	
      129:  289:	for (k = 0; k < maxconst; k++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
      128:  290:		parser->const_arr[k] = 1;
        -:  291:	};
        -:  292:	
        1:  293:	parser->expr_list = list_create();
call    0 returned 100%
        1:  294:	if (!parser->expr_list) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  295:		parser->error = pe_nomemory;
    #####:  296:		goto clean_up;
        -:  297:	}
        -:  298:
        1:  299:	parser->stack = pstack_create(stack_size);
call    0 returned 100%
        1:  300:	if (!parser->stack) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  301:		parser->error = pe_nomemory;
    #####:  302:		goto clean_up;
        -:  303:	}
        -:  304:
        1:  305:	iii = 1;
        -:  306:	/* adding some built-in variables */
        1:  307:	if (!parser_create_var(parser, "e", &e, &iii)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  308:		parser->error = pe_nomemory;
    #####:  309:		goto clean_up;
        -:  310:	};
        1:  311:	e = exp(1);
        -:  312:
        1:  313:	iii = 1;
        1:  314:	if (!parser_create_var(parser, "PI", &PI, &iii) ) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  315:		parser->error = pe_nomemory;
    #####:  316:		goto clean_up;
        -:  317:	};
        1:  318:	PI = acos(-1);
        -:  319:
        -:  320:	/* adding functions */	
        1:  321:	if (!parser_create_func_nocheck(parser, "+", 2, p_add)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  322:		parser->error = pe_nomemory;
    #####:  323:		goto clean_up;
        -:  324:	};
        -:  325:
        1:  326:	if (!parser_create_func_nocheck(parser, "-", 2, p_sub)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  327:		parser->error = pe_nomemory;
    #####:  328:		goto clean_up;
        -:  329:	};
        -:  330:
        1:  331:	if (!parser_create_func_nocheck(parser, "*", 2, p_mul)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  332:		parser->error = pe_nomemory;
    #####:  333:		goto clean_up;
        -:  334:	};
        -:  335:
        1:  336:	if (!parser_create_func_nocheck(parser, "/", 2, p_div)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  337:		parser->error = pe_nomemory;
    #####:  338:		goto clean_up;
        -:  339:	};
        -:  340:
        1:  341:	if (!parser_create_func_nocheck(parser, "^", 2, p_pow)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  342:		parser->error = pe_nomemory;
    #####:  343:		goto clean_up;
        -:  344:	};
        -:  345:
        1:  346:	if (!parser_create_func_nocheck(parser, "(", 0, NULL)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  347:		parser->error = pe_nomemory;
    #####:  348:		goto clean_up;
        -:  349:	};
        -:  350:
        1:  351:	if (!parser_create_func_nocheck(parser, ")", 0, NULL)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  352:		parser->error = pe_nomemory;
    #####:  353:		goto clean_up;
        -:  354:	};
        -:  355:
        1:  356:	if (!parser_create_func_nocheck(parser, "neg", 1, p_neg)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  357:		parser->error = pe_nomemory;
    #####:  358:		goto clean_up;
        -:  359:	};
        -:  360:
        1:  361:	if (!parser_create_func_nocheck(parser, "nul", 1, p_nul)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  362:		parser->error = pe_nomemory;
    #####:  363:		goto clean_up;
        -:  364:	};
        -:  365:
        -:  366:	/* adding functions from libm */
        1:  367:	prog = dlopen(NULL, RTLD_LAZY);
call    0 returned 100%
        1:  368:	if (!prog)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  369:		return parser;
        -:  370:	
       18:  371:	for (k = 0; k < LIBMNSYM; k++) {
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
       17:  372:		libmsym = dlsym(prog, libmsyms[k]);
call    0 returned 100%
       17:  373:		if ((dlerr = dlerror()) == NULL) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       17:  374:			parser_create_func_nocheck(parser, mfname[k], -1, libmsym);
call    0 returned 100%
        -:  375:		};
        -:  376:	};
        -:  377:
        1:  378:	dlclose(prog);
call    0 returned 100%
        1:  379:	return parser;
        -:  380:	
        -:  381:clean_up:
        -:  382:
    #####:  383:	if (parser->stack)
branch  0 never executed
branch  1 never executed
    #####:  384:		pstack_delete(parser->stack);
call    0 never executed
    #####:  385:	if (parser->imres)
branch  0 never executed
branch  1 never executed
    #####:  386:		free(parser->imres);
    #####:  387:	if (parser->fargs)
branch  0 never executed
branch  1 never executed
    #####:  388:		free(parser->fargs);
    #####:  389:	if (parser->const_arr)
branch  0 never executed
branch  1 never executed
    #####:  390:		free(parser->const_arr);
        -:  391:	
        -:  392:	/* all list except function list are empty */
    #####:  393:	if (parser->expr_list)
branch  0 never executed
branch  1 never executed
    #####:  394:		list_delete(parser->expr_list, NULL);
call    0 never executed
    #####:  395:	if (parser->var_list)
branch  0 never executed
branch  1 never executed
    #####:  396:		list_delete(parser->var_list, NULL);
call    0 never executed
    #####:  397:	if (parser->const_list)
branch  0 never executed
branch  1 never executed
    #####:  398:		list_delete(parser->const_list, NULL);
call    0 never executed
        -:  399:	
    #####:  400:	if (parser->fun_list)
branch  0 never executed
branch  1 never executed
    #####:  401:		list_delete(parser->fun_list, delete_expr_item);
call    0 never executed
        -:  402:	
    #####:  403:	free(parser);
    #####:  404:	return NULL;	
        -:  405:}
        -:  406:
function parser_create_var called 1028 returned 100% blocks executed 75%
     1028:  407:VAR* parser_create_var(PARSER*parser, char *varname, double *var, int *exists)
        -:  408:{
        -:  409:	VAR *newvar;
        -:  410:	VAR *oldvar;
        -:  411:	int k;
     1028:  412:	int readonly = *exists; /* save the value*/
        -:  413:	
     1028:  414:	if (!parser)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  415:		return NULL;
     1028:  416:	*exists = 0;
        -:  417:
     1028:  418:	parser->error = pe_ok; 
        -:  419:
     1028:  420:	if (!(isascii(varname[0]) && isalpha(varname[0]))) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
        1:  421:		parser->error = pe_invalidname;
        1:  422:		return NULL;
        -:  423:	};
        -:  424:	
     4021:  425:	for (k = 1; k < strlen(varname); k++) {
branch  0 taken 74%
branch  1 taken 26% (fallthrough)
     2994:  426:		if (!((isascii(varname[k]) && isalnum(varname[k])) || varname[k]=='_')) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 never executed
branch  6 never executed
    #####:  427:			parser->error = pe_invalidname;
    #####:  428:			return NULL;
        -:  429:		};
        -:  430:	};
        -:  431:
        -:  432:	/* already exists? */
     1027:  433:	oldvar = (VAR*)find_item_by_name(parser->var_list, (void*)varname);
call    0 returned 100%
     1027:  434:	if (oldvar) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        1:  435:		*exists = 1;
        1:  436:		if (oldvar->readonly) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  437:			parser->error = pe_readonly;
        1:  438:			return NULL;
        -:  439:		}
    #####:  440:		return oldvar;
        -:  441:	}
        -:  442:
        -:  443:/*
        -:  444:	oldvar = (VAR*)find_item_by_addr(parser->var_list, var);
        -:  445:	if (oldvar) {
        -:  446:	};
        -:  447:*/
        -:  448:
        -:  449:	/* also look it up in constant and function lists */
     1026:  450:	oldvar = (VAR*)find_item_by_name(parser->const_list, (void*)varname);
call    0 returned 100%
     1026:  451:	if (oldvar) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  452:		*exists = 1;
    #####:  453:		parser->error = pe_nameconflict;
    #####:  454:		return NULL;
        -:  455:	};
        -:  456:/*
        -:  457:	oldvar = (VAR*)find_item_by_addr(parser->const_list, var);
        -:  458:	if (oldvar) {
        -:  459:	}
        -:  460:*/
     1026:  461:	oldvar = (VAR*)find_item_by_name(parser->fun_list, (void*)varname);
call    0 returned 100%
     1026:  462:	if (oldvar) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  463:		*exists = 1;
    #####:  464:		parser->error = pe_nameconflict;
    #####:  465:		return NULL;
        -:  466:	};
        -:  467:/*
        -:  468:	oldvar = (VAR*)find_item_by_addr(parser->const_list, var);
        -:  469:	if ( oldvar ) {
        -:  470:	}
        -:  471:*/	
     1026:  472:	newvar = (VAR*)malloc(sizeof(VAR));
     1026:  473:	if (!newvar) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  474:		parser->error = pe_nomemory;
    #####:  475:		return NULL;
        -:  476:	};
        -:  477:	
     1026:  478:	newvar->name = varname;
     1026:  479:	newvar->type = variable;
     1026:  480:	newvar->loc  = var;
     1026:  481:	newvar->argnum = 0;
     1026:  482:	newvar->readonly = readonly;
        -:  483:	
     1026:  484:	if (!list_add(parser->var_list, (void*)newvar)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  485:		free(newvar);
    #####:  486:		parser->error = pe_nomemory;
    #####:  487:		return NULL;
        -:  488:	}
        -:  489:
     1026:  490:	return newvar;
        -:  491:}
        -:  492:
        -:  493:
        -:  494:/* for internal use only! */
function parser_addconst called 128 returned 100% blocks executed 71%
      128:  495:VAR* parser_addconst(PARSER*parser, char *cname, double *c)
        -:  496:{
        -:  497:	VAR * newvar;
        -:  498:
      128:  499:	newvar = (VAR*)malloc(sizeof(VAR));
      128:  500:	if (!newvar) return NULL;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  501:
      128:  502:	newvar->name = cname;
      128:  503:	newvar->type = constant;
      128:  504:	newvar->loc  = c;
      128:  505:	newvar->argnum = 0;
      128:  506:	newvar->readonly = 1;
        -:  507:
      128:  508:	if (!list_add(parser->const_list, (void*)newvar)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  509:		free(newvar);
    #####:  510:		return NULL;
        -:  511:	}
        -:  512:
      128:  513:	return newvar;
        -:  514:}
        -:  515:
function print_item called 31 returned 100% blocks executed 100%
       31:  516:int print_item(void*v)
        -:  517:{
       31:  518:	VAR * var = (VAR*)v;
       31:  519:	printf("%s", var->name);
call    0 returned 100%
       31:  520:	if (var->type != function ) {
branch  0 taken 16% (fallthrough)
branch  1 taken 84%
        5:  521:		printf(" = %f", *(double*)var->loc);
call    0 returned 100%
        5:  522:		if (var->readonly) {
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
        2:  523:			printf(" (readonly)\n");
call    0 returned 100%
        -:  524:		} else {
        3:  525:			printf("\n");
call    0 returned 100%
        -:  526:		}
        -:  527:	} else {
       26:  528:		printf("\n");
call    0 returned 100%
        -:  529:	};
       31:  530:	return 0;
        -:  531:}
        -:  532:
function parser_print_varlist called 1 returned 100% blocks executed 100%
        1:  533:void parser_print_varlist(PARSER*parser)
        -:  534:{
        1:  535:	list_foreach(parser->var_list, print_item);
call    0 returned 100%
        1:  536:}
        -:  537:
function parser_print_funclist called 1 returned 100% blocks executed 100%
        1:  538:void parser_print_funclist(PARSER*parser)
        -:  539:{
        1:  540:	list_foreach(parser->fun_list, print_item);
call    0 returned 100%
        1:  541:}
        -:  542:
function parser_print_constlist called 0 returned 0% blocks executed 0%
    #####:  543:void parser_print_constlist(PARSER*parser)
        -:  544:{
    #####:  545:	list_foreach(parser->const_list, print_item);
call    0 never executed
    #####:  546:}
        -:  547:
function print_expr_item called 0 returned 0% blocks executed 0%
    #####:  548:int print_expr_item(void*v)
        -:  549:{
    #####:  550:	EXPR_ITEM * ei = (EXPR_ITEM*)v;
    #####:  551:	if (ei->type != constant) {
branch  0 never executed
branch  1 never executed
    #####:  552:		printf("%s ", ei->name);
call    0 never executed
        -:  553:	} else {
    #####:  554:		printf("%f ", *(double*)ei->loc);
call    0 never executed
        -:  555:	};
    #####:  556:	return 0;
        -:  557:}
        -:  558:
function parser_print_expr_infix called 0 returned 0% blocks executed 0%
    #####:  559:void parser_print_expr_infix(PARSER*parser, EXPR *ex)
        -:  560:{
        -:  561:	
    #####:  562:	if (!list_find_by_addr(parser->expr_list, ex)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  563:		return;
        -:  564:	};
        -:  565:	
    #####:  566:	list_foreach(ex->postfix_list, print_expr_item);
call    0 never executed
    #####:  567:	printf("\n");
call    0 never executed
        -:  568:}
        -:  569:
function parser_print_expr_postfix called 0 returned 0% blocks executed 0%
    #####:  570:void parser_print_expr_postfix(PARSER*parser, EXPR *ex)
        -:  571:{
        -:  572:	
    #####:  573:	if (!list_find_by_addr(parser->expr_list, ex)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  574:		return;
        -:  575:	};
        -:  576:	
    #####:  577:	list_foreach(ex->postfix_list, print_expr_item);
call    0 never executed
    #####:  578:	printf("\n");
call    0 never executed
        -:  579:}
        -:  580:
function print_stack_item called 0 returned 0% blocks executed 0%
    #####:  581:void print_stack_item(void *data)
        -:  582:{
    #####:  583:	printf("%s ", (char*)data);
call    0 never executed
    #####:  584:}
        -:  585:
function print_stack called 0 returned 0% blocks executed 0%
    #####:  586:void print_stack(PSTACK*stk)
        -:  587:{
    #####:  588:	printf("stack: ");
call    0 never executed
    #####:  589:	pstack_print(stk, print_stack_item);
call    0 never executed
    #####:  590:	printf("\n");	
call    0 never executed
    #####:  591:}
        -:  592:
function parser_create_func_nocheck called 26 returned 100% blocks executed 70%
       26:  593:FUNC *parser_create_func_nocheck(PARSER *parser, char *funcname, int argnum, double (*f)(double *args))
        -:  594:{
        -:  595:	FUNC *newf;
        -:  596:	FUNC *oldf;
        -:  597:
        -:  598:	/* already exists? */
       26:  599:	oldf = (FUNC*)find_item_by_name(parser->fun_list, (void*)funcname);
call    0 returned 100%
        -:  600:
       26:  601:	if (oldf) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  602:		return oldf;
        -:  603:	}
        -:  604:
       26:  605:	newf = (FUNC*)malloc(sizeof(FUNC));
       26:  606:	if (!newf) return NULL;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  607:	
       26:  608:	newf->name = funcname;
       26:  609:	newf->type = function;
       26:  610:	newf->loc  = f;
       26:  611:	newf->argnum = argnum;
        -:  612:	
       26:  613:	if (!list_add(parser->fun_list, (void*)newf)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  614:		free(newf);
    #####:  615:		return NULL;
        -:  616:	}
        -:  617:	
       26:  618:	return newf;
        -:  619:}
        -:  620:
function parser_create_func called 0 returned 0% blocks executed 0%
    #####:  621:FUNC *parser_create_func(PARSER *parser, char *funcname, int argnum, double (*f)(double *args) )
        -:  622:{
        -:  623:	FUNC *newf;
        -:  624:	FUNC *oldf;
        -:  625:	int k;
        -:  626:
    #####:  627:	if (!parser) {
branch  0 never executed
branch  1 never executed
    #####:  628:		return NULL;
        -:  629:	};
        -:  630:	
    #####:  631:	parser->error = pe_ok; 
        -:  632:
    #####:  633:	if (!(isascii(funcname[0]) && isalpha(funcname[0]))) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  634:		parser->error = pe_invalidname;
    #####:  635:		return NULL;
        -:  636:	};
        -:  637:	
    #####:  638:	for (k = 1; k < strlen(funcname); k++) {
branch  0 never executed
branch  1 never executed
    #####:  639:		if (!((isascii(funcname[k]) && isalnum(funcname[k])) || funcname[k]=='_')) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  640:			parser->error = pe_invalidname;
    #####:  641:			return NULL;
        -:  642:		};
        -:  643:	};
        -:  644:
        -:  645:	/* already exists? */
    #####:  646:	oldf = (FUNC*)find_item_by_name(parser->fun_list, (void*)funcname);
call    0 never executed
    #####:  647:	if (oldf) {
branch  0 never executed
branch  1 never executed
    #####:  648:		return oldf;
        -:  649:	};
        -:  650:
        -:  651:
    #####:  652:	oldf = (FUNC*)find_item_by_name(parser->var_list, (void*)funcname);
call    0 never executed
    #####:  653:	if (oldf) {
branch  0 never executed
branch  1 never executed
    #####:  654:		parser->error = pe_nameconflict;
    #####:  655:		return NULL;
        -:  656:	};
        -:  657:
    #####:  658:	oldf = (FUNC*)find_item_by_name(parser->const_list, (void*)funcname);
call    0 never executed
    #####:  659:	if (oldf) {
branch  0 never executed
branch  1 never executed
    #####:  660:		parser->error = pe_nameconflict;
    #####:  661:		return NULL;
        -:  662:	};
        -:  663:	
    #####:  664:	newf = (FUNC*)malloc(sizeof(FUNC));
    #####:  665:	if (!newf) {
branch  0 never executed
branch  1 never executed
    #####:  666:		parser->error = pe_nomemory;
    #####:  667:		return NULL;
        -:  668:	}
        -:  669:	
    #####:  670:	newf->name = funcname;
    #####:  671:	newf->type = function;
    #####:  672:	newf->loc  = f;
    #####:  673:	newf->argnum = argnum;
        -:  674:	
    #####:  675:	if (!list_add(parser->fun_list, (void*)newf)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  676:		free(newf);
    #####:  677:		parser->error = pe_nomemory;
    #####:  678:		return NULL;
        -:  679:	}
        -:  680:	
    #####:  681:	return newf;
        -:  682:}
        -:  683:
        -:  684:/*
        -:  685:ITEM_TYPE token_type(PARSER*parser, char*tok)
        -:  686:{
        -:  687:	EXPR_ITEM ei;
        -:  688:	
        -:  689:	if (isdigit(tok[0]) || (tok[0] == '.')) 
        -:  690:		return constant;
        -:  691:		
        -:  692:	if ((tok[0] == '(') || (tok[0] == ')')) 
        -:  693:		return function;
        -:  694:	
        -:  695:	ei.name = tok;
        -:  696:		
        -:  697:	if (list_find_first(parser->var_list, (void*)&ei, check_item_name))
        -:  698:		return variable;
        -:  699:		
        -:  700:	if (list_find_first(parser->fun_list, (void*)&ei, check_item_name))
        -:  701:		return function;
        -:  702:		
        -:  703:	return unknownid;
        -:  704:}
        -:  705:*/
        -:  706:
function priority called 181 returned 100% blocks executed 79%
      181:  707:int priority(char op1, char op2)
        -:  708:{
      181:  709:	if (op1 == ')')
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  710:		return -1;
        -:  711:
      181:  712:	if (op1 == '(' )
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
       30:  713:		return 0;
        -:  714:
      151:  715:	if ((op1 != ')') && (op2 == '(') )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 17% (fallthrough)
branch  3 taken 83%
       26:  716:		return 0;
        -:  717:
      125:  718:	if (isalpha(op2))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  719:		return 0; /* function */
        -:  720:
      125:  721:	if (op2 == '^')
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  722:		return 0;
        -:  723:
      125:  724:	if ((( op1 == '+') || (op1 == '-')) && ( (op2 == '*') || (op2 == '/')))
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####:  725:		return 0;
        -:  726:
      125:  727:	return 1;
        -:  728:}
        -:  729:
        -:  730:char *delims = "+-()^*/,";
        -:  731:
function find_item called 232 returned 100% blocks executed 100%
      232:  732:EXPR_ITEM* find_item(PARSER*p, char*name)
        -:  733:{
        -:  734:	EXPR_ITEM * ei;
        -:  735:
      232:  736:	ei = find_item_by_name(p->var_list, name);
call    0 returned 100%
      232:  737:	if (ei) 
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       14:  738:		return ei;
        -:  739:
      218:  740:	ei = find_item_by_name(p->fun_list, name);
call    0 returned 100%
      218:  741:	if (ei) 
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      216:  742:		return ei;
        -:  743:
        2:  744:	return NULL;
        -:  745:}
        -:  746:
function valid_const called 1184 returned 100% blocks executed 88%
     1184:  747:int valid_const(char *cstr)
        -:  748:{
        -:  749:	int k;
        -:  750:	int valid;
        -:  751:	int dots;
        -:  752:
     1184:  753:	dots = 0;
     2639:  754:	for (k = 0; k < strlen(cstr); k++) {
branch  0 taken 55%
branch  1 taken 45% (fallthrough)
     1456:  755:		valid = (isdigit(cstr[k]) || (cstr[k] == '.'));
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
     1456:  756:		if (cstr[k] == '.')
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  757:			dots++;
     1456:  758:		if (dots > 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  759:			valid = 0;
     1456:  760:		if (!valid )
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        1:  761:			break;
        -:  762:	};
     1184:  763:	return valid;
        -:  764:}
        -:  765:
function parser_create_expr called 1070 returned 100% blocks executed 87%
     1070:  766:EXPR* parser_create_expr(PARSER *parser, char *expr_str)
        -:  767:{
     1070:  768:	EXPR *e = NULL;
     1070:  769:	char *e_str = NULL;
     1070:  770:	char *tmp = NULL, *tmpsave = NULL;
     1070:  771:	char *token = NULL;
        -:  772:	int len, m, k, olen;
        -:  773:	char c;
        -:  774:	double v;
     1070:  775:	char ariff[2] = " ";
     1070:  776:	char *neg = "neg";
     1070:  777:	char *nul = "nul";
     1070:  778:	EXPR_ITEM *item = NULL;
        -:  779:	int unop;
     1070:  780:	char *cname = NULL;
        -:  781:	char cn[MAXCSTRLEN];
        -:  782:
     1070:  783:	if (!parser)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  784:		return NULL;
     1070:  785:	if (!expr_str)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  786:		return NULL;
        -:  787:
     1070:  788:	parser->error = pe_ok;
        -:  789:
     1070:  790:	e = (EXPR*)malloc(sizeof(EXPR));
     1070:  791:	if (!e) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  792:		parser->error = pe_nomemory;
    #####:  793:		goto clean_up;
        -:  794:	}
        -:  795:
     1070:  796:	e->postfix_list = list_create();
call    0 returned 100%
        -:  797:	
     1070:  798:	if (!e->postfix_list) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  799:		parser->error = pe_nomemory;
    #####:  800:		goto clean_up;
        -:  801:	};
        -:  802:
        -:  803:	/* how many spaces we have? */
        -:  804:	{
     1070:  805:		int spaces = 0;
        -:  806:		int k;
     1070:  807:		olen = len = strlen(expr_str);
        -:  808:		
    11397:  809:		for (k = 0; k < olen; k++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
    10327:  810:			if (expr_str[k] == ' ') spaces++;
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  811:		};
     1070:  812:		len -= spaces;
        -:  813:	};
        -:  814:	
     1070:  815:	e_str = (char*)malloc(len + 1); /* 1 for terminating \0 */
     1070:  816:	if (!e_str) { 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  817:		parser->error = pe_nomemory;
    #####:  818:		goto clean_up;
        -:  819:	};
        -:  820:
     1070:  821:	tmp = malloc(len + 1); /* 1 for terminating \0 */
     1070:  822:	tmpsave = tmp;
     1070:  823:	if (!tmp) { 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  824:		parser->error = pe_nomemory;
    #####:  825:		goto clean_up;
        -:  826:	};
        -:  827:	
     1070:  828:	e_str[len] = '\0';
        -:  829:	
     1070:  830:	m = 0;
    11397:  831:	for (k = 0; k < olen; k++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
    10327:  832:		if (expr_str[k] != ' ') {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
    10316:  833:			e_str[m] = expr_str[k];
    10316:  834:			m++;
        -:  835:		};
        -:  836:	};
        -:  837:	
        -:  838:/*
        -:  839:	checking brakets
        -:  840:*/
     1070:  841:	pstack_clear(parser->stack);
call    0 returned 100%
        -:  842:	
     8927:  843:	for (k = 0; k < len; k++) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
     7858:  844:		if (e_str[k] == '(') { 
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
      539:  845:			if (pstack_full(parser->stack)) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        1:  846:				parser->error = pe_exprtoocomp;
        1:  847:				goto clean_up;
        -:  848:			};
      538:  849:			pstack_push(parser->stack,tmp);
call    0 returned 100%
        -:  850:		};
     7857:  851:		if (e_str[k] == ')') { 
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
       26:  852:			if (pstack_empty(parser->stack)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  853:				parser->error = pe_syntax;
    #####:  854:				goto clean_up;
        -:  855:			};
       26:  856:			pstack_pop(parser->stack);
call    0 returned 100%
        -:  857:		};
        -:  858:	};
        -:  859:
     1069:  860:	if (!pstack_empty(parser->stack)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  861:		parser->error = pe_syntax;
    #####:  862:		goto clean_up;
        -:  863:	};
        -:  864:	
     1069:  865:	e->infix_str = e_str;
     1069:  866:	strcpy(tmp, e_str);
        -:  867:	
        -:  868:	/* 
        -:  869:		parsing expression string in infix notation
        -:  870:		and create expression list in postfix notation
        -:  871:	*/
        -:  872:	
     1069:  873:	k = 0; /* position of first unparsed symbol */
     1069:  874:	m = 0; /* flag for strtok() */
     1069:  875:	pstack_clear(parser->stack);
call    0 returned 100%
        -:  876:	
     1069:  877:	while (k < len) {
branch  0 taken 57%
branch  1 taken 43% (fallthrough)
     1416:  878:		c = e_str[k];
     1416:  879:		if (strchr(delims, (int)c)) {
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
        -:  880:			/* it's an operation */
      189:  881:			ariff[0] = c;
      189:  882:			token = ariff;
        -:  883:			
        -:  884:			/* check for unary minus or plus */
      189:  885:			if ((c == '-') || (c == '+') ) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
branch  2 taken 68% (fallthrough)
branch  3 taken 32%
      131:  886:				unop = ((!k) || ((k) && (!isalnum(e_str[k-1])) && ( e_str[k-1] != ')')));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
branch  5 taken 3% (fallthrough)
branch  6 taken 97%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
        -:  887:			};
      189:  888:			k++;
        -:  889:
      189:  890:			if (unop) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
       62:  891:				if ( c == '-' ) {
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        4:  892:					token = neg;
        -:  893:				};
       62:  894:				if ( c == '+' ) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  895:					token = nul;
        -:  896:				};
        -:  897:			};
        -:  898:		} else { /* it is a function, a variable or numeric constant */
     1227:  899:			if (m) {
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
      158:  900:				token = strtok(NULL, delims);
call    0 returned 100%
        -:  901:			} else {
     1069:  902:				token = strtok(tmp, delims);
call    0 returned 100%
     1069:  903:				m = 1;
        -:  904:			};
     1227:  905:			k += strlen(token);
        -:  906:		};
        -:  907:		
        -:  908:		/* check if it is constant */
     2598:  909:		if ((token[0] == '.') || (isdigit(token[0]))) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 84% (fallthrough)
branch  4 taken 16%
        -:  910:			EXPR_ITEM *ei;
     1184:  911:			if (!valid_const(token)) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        1:  912:				parser->error = pe_invalidconst;
        1:  913:				goto clean_up;
        -:  914:			};
     1183:  915:			if (!sscanf(token, "%lf", &v)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  916:				parser->error = pe_invalidconst;
    #####:  917:				goto clean_up;
        -:  918:			};
        -:  919:			
     1183:  920:			ei = find_item_by_val(parser->const_list, v);
call    0 returned 100%
        -:  921:
     1183:  922:			if (!ei) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
      129:  923:				cname = (char*)malloc(parser->const_nmlen);
      129:  924:				if (!cname) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  925:					parser->error = pe_nomemory;
    #####:  926:					goto clean_up;
        -:  927:				};
        -:  928:
      129:  929:				if (parser->last_const == parser->maxconst) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        1:  930:					parser->error = pe_constarrfull;
        1:  931:					goto clean_up;
        -:  932:				};
        -:  933:				
      128:  934:				strcpy(cname, cprefix);
      128:  935:				sprintf(cn,"%d", parser->last_const);
      128:  936:				strcat(cname,cn);
        -:  937:				
      128:  938:				parser->const_arr[parser->last_const] = v;
        -:  939:				
      128:  940:				ei = parser_addconst(parser, cname, &parser->const_arr[parser->last_const]);
call    0 returned 100%
      128:  941:				parser->last_const++;
        -:  942:				
      128:  943:				if (!ei) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  944:					parser->error = pe_nomemory;
    #####:  945:					goto clean_up;
        -:  946:				};
        -:  947:				
        -:  948:			};
     1182:  949:			item = ei;
        -:  950:		} else {
      232:  951:			item = find_item(parser, token);
call    0 returned 100%
        -:  952:		};
        -:  953:		
     1414:  954:		if (!item) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2:  955:			parser->error = pe_unknownid;
        2:  956:			goto clean_up;
        -:  957:		};
        -:  958:		
     1412:  959:		switch ( item->type ) {
branch  0 taken 85%
branch  1 taken 15%
branch  2 taken 0%
branch  3 taken 0%
        -:  960:		
        -:  961:	case constant:
        -:  962:	case variable:
     1196:  963:		if (!list_add(e->postfix_list, (void*)item)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  964:			parser->error = pe_nomemory;
    #####:  965:			goto clean_up;
        -:  966:		};
     1196:  967:	break;
        -:  968:		
        -:  969:	case function:
        -:  970:		while (1) {
        -:  971:			EXPR_ITEM * otop;
      341:  972:			if (pstack_empty(parser->stack))
call    0 returned 100%
branch  1 taken 47% (fallthrough)
branch  2 taken 53%
      160:  973:				break;
      181:  974:			otop = (EXPR_ITEM*)pstack_peek(parser->stack);
call    0 returned 100%
      181:  975:			if (!priority(otop->name[0],item->name[0]))
call    0 returned 100%
branch  1 taken 31% (fallthrough)
branch  2 taken 69%
       56:  976:				break;
      125:  977:			otop = (EXPR_ITEM*)pstack_pop(parser->stack);
call    0 returned 100%
      125:  978:			if (!list_add(e->postfix_list, (void*)otop)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  979:				parser->error = pe_nomemory;
    #####:  980:				goto clean_up;
        -:  981:			};
      125:  982:		};
      216:  983:		if (item->name[0] != ')') {
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  984://			if (pstack_full(parser->stack) ) {
        -:  985://				parser->error = pe_stack_overflow;
        -:  986://				goto clean_up;
        -:  987://			};
      190:  988:			pstack_push(parser->stack, item);
call    0 returned 100%
        -:  989:		} else {
        -:  990://			if (pstack_empty(parser->stack) ) {
        -:  991://				parser->error = pe_syntax; /* ??? */
        -:  992://				goto clean_up;
        -:  993://			};
       26:  994:			pstack_pop(parser->stack); /* throw away '('*/
call    0 returned 100%
        -:  995:		};
      216:  996:	break;
        -:  997:	
        -:  998:	/* never happen */
        -:  999:	case unknownid:
    #####: 1000:		parser->error = pe_bug;
    #####: 1001:		goto clean_up;
        -: 1002:	break;
        -: 1003:		}; /* */
        -: 1004:		
        -: 1005:	}; /* while there are tokens */
        -: 1006:
     2167: 1007:	while (!pstack_empty(parser->stack)) {
call    0 returned 100%
branch  1 taken 3%
branch  2 taken 97% (fallthrough)
       37: 1008:		EXPR_ITEM * op = pstack_pop(parser->stack);
call    0 returned 100%
       37: 1009:		if ( !list_add(e->postfix_list, op) ) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1010:			parser->error = pe_nomemory;
    #####: 1011:			goto clean_up;
        -: 1012:		};
        -: 1013:	};
        -: 1014:
        -: 1015:	{
     1065: 1016:		PARSER_ERROR aaa = valid_expr(parser, e);
call    0 returned 100%
     1065: 1017:		if (aaa != pe_ok) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2: 1018:			parser->error = aaa;
        2: 1019:			goto clean_up;
        -: 1020:		};
        -: 1021:	}
        -: 1022:	
     1063: 1023:	if (!list_add(parser->expr_list, (void*)e)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1024:		parser->error = pe_nomemory;
    #####: 1025:		goto clean_up;
        -: 1026:	};
     1063: 1027:	return e;
        -: 1028:
        -: 1029:clean_up:
        -: 1030:
        7: 1031:	if (tmpsave)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7: 1032:		free(tmpsave);
        7: 1033:	if (e_str)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7: 1034:		free(e_str);
        7: 1035:	if (e->postfix_list )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7: 1036:		list_delete(e->postfix_list, NULL);
call    0 returned 100%
        7: 1037:	if (e)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7: 1038:		free(e);
        7: 1039:	return NULL;
        -: 1040:}
        -: 1041:
function valid_expr called 1065 returned 100% blocks executed 82%
     1065: 1042:PARSER_ERROR valid_expr(PARSER *parser, EXPR *ex)
        -: 1043:{
     1065: 1044:	double *tmp = NULL;
        -: 1045:	LIST_ITEM *itemp;
        -: 1046:	EXPR_ITEM *cei;
        -: 1047:	int k;
        -: 1048:
        -: 1049:	int argnum;
        -: 1050:
     1065: 1051:	itemp = ex->postfix_list->top;
     1065: 1052:	pstack_clear(parser->stack);
call    0 returned 100%
        -: 1053:
     3242: 1054:	while (itemp) {
branch  0 taken 51%
branch  1 taken 49% (fallthrough)
     1114: 1055:		cei = (EXPR_ITEM*)itemp->data;
     1114: 1056:		switch (cei->type) {
branch  0 taken 96%
branch  1 taken 4%
branch  2 taken 0%
branch  3 taken 0%
        -: 1057:
        -: 1058:		case constant:
        -: 1059:		case variable:
     1073: 1060:			if (pstack_full(parser->stack)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1061:				return pe_exprtoocomp;
        -: 1062:			};
     1073: 1063:			pstack_push(parser->stack, tmp);
call    0 returned 100%
     1073: 1064:		break;
        -: 1065:
        -: 1066:		case function:
       41: 1067:			argnum = abs(cei->argnum);
       90: 1068:			for (k = argnum - 1; k >= 0; k--) {
branch  0 taken 57%
branch  1 taken 43% (fallthrough)
       51: 1069:				if (pstack_empty(parser->stack)) {
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
        2: 1070:					return pe_syntax;
        -: 1071:				};
       49: 1072:				pstack_pop(parser->stack);
call    0 returned 100%
        -: 1073:			};
       39: 1074:			if (pstack_full(parser->stack)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1075:				return pe_exprtoocomp;
        -: 1076:			};
       39: 1077:			pstack_push(parser->stack, tmp);
call    0 returned 100%
       39: 1078:		break;
        -: 1079:
        -: 1080:		case unknownid:
    #####: 1081:			printf("BUG: unknown item id\n");
call    0 never executed
    #####: 1082:			exit(1);
call    0 never executed
        -: 1083:		break;
        -: 1084:		}
     1112: 1085:		itemp = itemp->next;
        -: 1086:	};
        -: 1087:
     1063: 1088:	if (pstack_empty(parser->stack))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1089:		return pe_syntax;
     1063: 1090:	pstack_pop(parser->stack);
call    0 returned 100%
     1063: 1091:	if (!pstack_empty(parser->stack))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1092:		return pe_syntax;
        -: 1093:
     1063: 1094:	return pe_ok;
        -: 1095:}
        -: 1096:
function parser_eval_expr called 1063 returned 100% blocks executed 88%
     1063: 1097:double parser_eval_expr(PARSER *parser, EXPR *ex)
        -: 1098:{
        -: 1099:	double *tmp;
        -: 1100:	LIST_ITEM *itemp;
        -: 1101:	EXPR_ITEM *cei;
        -: 1102:	int k;
        -: 1103:	double (*op)(double*);
        -: 1104:	double (*mlop)(double);
        -: 1105:	
        -: 1106:	int ind, argnum;
        -: 1107:	
     1063: 1108:	if (!parser)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1109:		return 0;
     1063: 1110:	if (!ex)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1111:		return 0;
        -: 1112:
     1063: 1113:	itemp = ex->postfix_list->top;
     1063: 1114:	ind = 0;
        -: 1115:
     1063: 1116:	pstack_clear(parser->stack);
call    0 returned 100%
        -: 1117:
     3237: 1118:	while (itemp) {
branch  0 taken 51%
branch  1 taken 49% (fallthrough)
     1111: 1119:		cei = (EXPR_ITEM*)itemp->data;
     1111: 1120:		switch (cei->type) {
branch  0 taken 96%
branch  1 taken 4%
branch  2 taken 0%
branch  3 taken 0%
        -: 1121:
        -: 1122:		case constant:
        -: 1123:		case variable:
        -: 1124:			/* error? */
     1072: 1125:			pstack_push(parser->stack, cei->loc);
call    0 returned 100%
     1072: 1126:		break;
        -: 1127:
        -: 1128:		case function:
       39: 1129:			argnum = abs(cei->argnum);
       87: 1130:			for (k = argnum-1; k >= 0; k--) {
branch  0 taken 55%
branch  1 taken 45% (fallthrough)
       48: 1131:				tmp = pstack_pop(parser->stack);
call    0 returned 100%
       48: 1132:				parser->fargs[k] = *(double*)tmp;
        -: 1133:			};
       39: 1134:			if (cei->argnum == -1) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
       24: 1135:				mlop = cei->loc;
       24: 1136:				parser->imres[ind] = mlop(parser->fargs[0]);
call    0 returned 100%
        -: 1137:			} else {
       15: 1138:				op = cei->loc;
       15: 1139:				parser->imres[ind] = op(parser->fargs);
call    0 returned 100%
        -: 1140:			}
       39: 1141:			pstack_push(parser->stack, &parser->imres[ind]);
call    0 returned 100%
       39: 1142:			ind++;
       39: 1143:		break;
        -: 1144:
        -: 1145:		case unknownid:
    #####: 1146:		break;
        -: 1147:		}
     1111: 1148:		itemp = itemp->next;
        -: 1149:	}
     1063: 1150:	tmp = pstack_pop(parser->stack);
call    0 returned 100%
     1063: 1151:	return *tmp;
        -: 1152:}
        -: 1153:
function delete_expr called 1063 returned 100% blocks executed 100%
     1063: 1154:void delete_expr(void *ex)
        -: 1155:{
        -: 1156:	/* what to do with char *infix_str ?*/
     1063: 1157:	EXPR *exp = (EXPR*)ex;
     1063: 1158:	LIST *exl = exp->postfix_list;
     1063: 1159:	list_delete(exl, NULL);
call    0 returned 100%
        -: 1160:	/* 
        -: 1161:	 * no need to delete items since they are
        -: 1162:	 * in var, func and const lists
        -: 1163:	 */
     1063: 1164:}
        -: 1165:
function parser_delete called 1 returned 100% blocks executed 100%
        1: 1166:void parser_delete(PARSER*parser)
        -: 1167:{
        1: 1168:	list_delete(parser->expr_list, delete_expr);
call    0 returned 100%
        1: 1169:	list_delete(parser->var_list, delete_expr_item);
call    0 returned 100%
        1: 1170:	list_delete(parser->fun_list, delete_expr_item);
call    0 returned 100%
        1: 1171:	list_delete(parser->const_list, delete_expr_item); 
call    0 returned 100%
        -: 1172:
        1: 1173:	free(parser->const_arr);
        1: 1174:	free(parser->imres);
        1: 1175:	free(parser->fargs);
        1: 1176:	pstack_delete(parser->stack);
call    0 returned 100%
        -: 1177:	
        1: 1178:	free(parser);
        1: 1179:}
